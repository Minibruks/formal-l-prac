# Формальные языки. Практическая домашняя работа #
## Вариант 11. Смирнов Павел Б05-032 ##

### Алгоритм ###
Будем использовать идеи динамического программирования. Заведем массив расстояний, где в *i*-ой ячейке будет храниться кратчайшее растояние от стартового состояния до состояния *i* (считаем его терминальным в этот момент), содержащего ровно *k'* букв *x*. Читаем выражние, парся обратную польскую запись: если встретили операцию '.' на *i*-ом шаге и достали со стека регулярные выражения *a* и *b*, то значит, что получить слово с *i* буквами *x* можно взяв слово с *n* буквами из *a* и *i - n* буквами из *b* и взять минимум среди всех.

Далее, если встретили операцию '+' на *i*-ом шаге и достали со стека регулярные выражения *a* и *b*, то значит, что получить слово с *i* буквами *x* взяв минимум среди расстояний до *a* и *b*.

И наконец, если встретили унарную операцию '*', то пробуем пересчитать наш массив расстояний на каждом шаге.

Итак, ответ на задачу будет храниться в ячейке массива под номером *k*. Корректность алгоритма следует из описания его работы (так как само вычисление расстояния происхоит фактически по индукции, а переход индукции, то есть три операции, я обосновал).

### Время работы ###
Добавление буквы - *O(1)*, конкатенация - *O(k^2)*, объединение - *O(k)*, звезда Клини - *O(k^2)*. А всего *n* элементов в обратной польской нотации, то есть общее время работы составляет *O(n * k^2)*.

В файле coverage.png скрин, где видно покрытие тестами основных файлов. 

Изначально я хотел решать задачу с помощью построения примитивного НКА, но в последствии я отказался от этой идеи, но код построения НКА лежит в nfa.cpp
